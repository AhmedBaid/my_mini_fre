<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TodoMVC - MiniFlux</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
        }

        button {
            margin: 0;
            padding: 0;
            border: 0;
            background: none;
            font-size: 100%;
            vertical-align: baseline;
            font-family: inherit;
            font-weight: inherit;
            color: inherit;
            -webkit-appearance: none;
            appearance: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
            line-height: 1.4em;
            background: #f5f5f5;
            color: #4d4d4d;
            min-width: 230px;
            max-width: 550px;
            margin: 0 auto;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-weight: 300;
        }

        :focus {
            outline: 0;
        }

        .hidden {
            display: none;
        }

        .todoapp {
            background: #fff;
            margin: 130px 0 40px 0;
            position: relative;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
                0 25px 50px 0 rgba(0, 0, 0, 0.1);
        }

        .todoapp input::-webkit-input-placeholder {
            font-style: italic;
            font-weight: 300;
            color: #e6e6e6;
        }

        .todoapp input::-moz-placeholder {
            font-style: italic;
            font-weight: 300;
            color: #e6e6e6;
        }

        .todoapp input::input-placeholder {
            font-style: italic;
            font-weight: 300;
            color: #e6e6e6;
        }

        .todoapp h1 {
            position: absolute;
            top: -155px;
            width: 100%;
            font-size: 100px;
            font-weight: 100;
            text-align: center;
            color: rgba(175, 47, 47, 0.15);
            -webkit-text-rendering: optimizeLegibility;
            -moz-text-rendering: optimizeLegibility;
            text-rendering: optimizeLegibility;
        }

        .new-todo,
        .edit {
            position: relative;
            margin: 0;
            width: 100%;
            font-size: 24px;
            font-family: inherit;
            font-weight: inherit;
            line-height: 1.4em;
            color: inherit;
            padding: 6px;
            border: 1px solid #999;
            box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .new-todo {
            padding: 16px 16px 16px 60px;
            border: none;
            background: rgba(0, 0, 0, 0.003);
            box-shadow: inset 0 -2px 1px rgba(0, 0, 0, 0.03);
        }

        .main {
            position: relative;
            z-index: 2;
            border-top: 1px solid #e6e6e6;
        }

        .toggle-all {
            width: 1px;
            height: 1px;
            border: none;
            opacity: 0;
            position: absolute;
            right: 100%;
            bottom: 100%;
        }

        .toggle-all+label {
            width: 60px;
            height: 34px;
            font-size: 0;
            position: absolute;
            top: -52px;
            left: -13px;
            -webkit-transform: rotate(90deg);
            transform: rotate(90deg);
        }

        .toggle-all+label:before {
            content: '❯';
            font-size: 22px;
            color: #e6e6e6;
            padding: 10px 27px 10px 27px;
        }

        .toggle-all:checked+label:before {
            color: #737373;
        }

        .todo-list {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .todo-list li {
            position: relative;
            font-size: 24px;
            border-bottom: 1px solid #ededed;
        }

        .todo-list li:last-child {
            border-bottom: none;
        }

        .todo-list li.editing {
            border-bottom: none;
            padding: 0;
        }

        .todo-list li.editing .edit {
            display: block;
            width: calc(100% - 43px);
            padding: 12px 16px;
            margin: 0 0 0 43px;
        }

        .todo-list li.editing .view {
            display: none;
        }

        .todo-list li .toggle {
            text-align: center;
            width: 40px;
            height: auto;
            position: absolute;
            top: 0;
            bottom: 0;
            margin: auto 0;
            border: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .todo-list li .toggle {
            opacity: 0;
        }

        .todo-list li .toggle+label {
            background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: center left;
        }

        .todo-list li .toggle:checked+label {
            background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E');
        }

        .todo-list li label {
            word-break: break-all;
            padding: 15px 15px 15px 60px;
            display: block;
            line-height: 1.2;
            transition: color 0.4s;
        }

        .todo-list li.completed label {
            color: #d9d9d9;
            text-decoration: line-through;
        }

        .todo-list li .destroy {
            display: none;
            position: absolute;
            top: 0;
            right: 10px;
            bottom: 0;
            width: 40px;
            height: 40px;
            margin: auto 0;
            font-size: 30px;
            color: #cc9a9a;
            margin-bottom: 11px;
            transition: color 0.2s ease-out;
        }

        .todo-list li .destroy:hover {
            color: #af5b5e;
        }

        .todo-list li .destroy:after {
            content: '×';
        }

        .todo-list li:hover .destroy {
            display: block;
        }

        .todo-list li .edit {
            display: none;
        }

        .todo-list li.editing:last-child {
            margin-bottom: -1px;
        }

        .footer {
            color: #777;
            padding: 10px 15px;
            height: 20px;
            text-align: center;
            border-top: 1px solid #e6e6e6;
        }

        .footer:before {
            content: '';
            position: absolute;
            right: 0;
            bottom: 0;
            left: 0;
            height: 50px;
            overflow: hidden;
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
                0 8px 0 -3px #f6f6f6,
                0 9px 1px -3px rgba(0, 0, 0, 0.2),
                0 16px 0 -6px #f6f6f6,
                0 17px 2px -6px rgba(0, 0, 0, 0.2);
        }

        .todo-count {
            float: left;
            text-align: left;
        }

        .todo-count strong {
            font-weight: 300;
        }

        .filters {
            margin: 0;
            padding: 0;
            list-style: none;
            position: absolute;
            right: 0;
            left: 0;
        }

        .filters li {
            display: inline;
        }

        .filters li a {
            color: inherit;
            margin: 3px;
            padding: 3px 7px;
            text-decoration: none;
            border: 1px solid transparent;
            border-radius: 3px;
        }

        .filters li a:hover {
            border-color: rgba(175, 47, 47, 0.1);
        }

        .filters li a.selected {
            border-color: rgba(175, 47, 47, 0.2);
        }

        .clear-completed,
        html .clear-completed:active {
            float: right;
            position: relative;
            line-height: 20px;
            text-decoration: none;
            cursor: pointer;
        }

        .clear-completed:hover {
            text-decoration: underline;
        }

        .info {
            margin: 65px auto 0;
            color: #bfbfbf;
            font-size: 10px;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
            text-align: center;
        }

        .info p {
            line-height: 1;
        }

        .info a {
            color: inherit;
            text-decoration: none;
            font-weight: 400;
        }

        .info a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div id="app"></div>

    <script>
        /**
         * MiniFlux Framework
         */
        (function (global) {
            'use strict';

            function h(tag, attrs, ...children) {
                attrs = attrs || {};
                children = children.flat(Infinity).filter(c => c != null && c !== false);

                return {
                    tag,
                    attrs,
                    children: children.map(child =>
                        typeof child === 'object' && child.tag
                            ? child
                            : createTextVNode(child)
                    ),
                    key: attrs.key
                };
            }

            function createTextVNode(text) {
                return {
                    tag: 'TEXT',
                    attrs: {},
                    children: [],
                    text: String(text)
                };
            }

            let oldVNode = null;

            function render(vnode, container) {
                if (!oldVNode) {
                    const dom = createElement(vnode);
                    container.innerHTML = '';
                    container.appendChild(dom);
                    oldVNode = vnode;
                } else {
                    const patches = diff(oldVNode, vnode);
                    patch(container.firstChild, patches);
                    oldVNode = vnode;
                }
            }

            function createElement(vnode) {
                if (vnode.tag === 'TEXT') {
                    return document.createTextNode(vnode.text);
                }

                const el = document.createElement(vnode.tag);
                setAttributes(el, vnode.attrs);
                vnode.children.forEach(child => {
                    el.appendChild(createElement(child));
                });

                return el;
            }

            function setAttributes(el, attrs) {
                Object.keys(attrs).forEach(key => {
                    setAttribute(el, key, attrs[key]);
                });
            }

            function setAttribute(el, key, value) {
                if (key === 'className') key = 'class';

                if (key.startsWith('on')) {
                    const eventName = key.substring(2).toLowerCase();
                    el.addEventListener(eventName, value);
                    return;
                }

                if (key === 'style' && typeof value === 'object') {
                    Object.assign(el.style, value);
                    return;
                }

                if (key === 'checked' || key === 'disabled') {
                    el[key] = value;
                    return;
                }

                if (key === 'value') {
                    el.value = value;
                    return;
                }

                if (value === true) {
                    el.setAttribute(key, '');
                } else if (value !== false && value != null) {
                    el.setAttribute(key, value);
                }
            }

            function diff(oldVNode, newVNode) {
                if (!oldVNode || oldVNode.tag !== newVNode.tag) {
                    return { type: 'REPLACE', newVNode };
                }

                if (newVNode.tag === 'TEXT') {
                    if (oldVNode.text !== newVNode.text) {
                        return { type: 'TEXT', text: newVNode.text };
                    }
                    return null;
                }

                const attrPatches = diffAttrs(oldVNode.attrs, newVNode.attrs);
                const childPatches = diffChildren(oldVNode.children, newVNode.children);

                if (!attrPatches && !childPatches) {
                    return null;
                }

                return {
                    type: 'UPDATE',
                    attrPatches,
                    childPatches
                };
            }

            function diffAttrs(oldAttrs, newAttrs) {
                const patches = {};
                let hasPatches = false;

                for (let key in newAttrs) {
                    if (oldAttrs[key] !== newAttrs[key]) {
                        patches[key] = newAttrs[key];
                        hasPatches = true;
                    }
                }

                for (let key in oldAttrs) {
                    if (!(key in newAttrs)) {
                        patches[key] = undefined;
                        hasPatches = true;
                    }
                }

                return hasPatches ? patches : null;
            }

            function diffChildren(oldChildren, newChildren) {
                const patches = [];
                const maxLength = Math.max(oldChildren.length, newChildren.length);

                for (let i = 0; i < maxLength; i++) {
                    const oldChild = oldChildren[i];
                    const newChild = newChildren[i];

                    if (!oldChild) {
                        patches.push({ type: 'ADD', newVNode: newChild });
                    } else if (!newChild) {
                        patches.push({ type: 'REMOVE' });
                    } else {
                        const patch = diff(oldChild, newChild);
                        patches.push(patch);
                    }
                }

                return patches.length > 0 ? patches : null;
            }

            function patch(el, patches) {
                if (!patches || !el) return el;

                if (patches.type === 'REPLACE') {
                    const newEl = createElement(patches.newVNode);
                    el.parentNode.replaceChild(newEl, el);
                    return newEl;
                }

                if (patches.type === 'TEXT') {
                    el.textContent = patches.text;
                    return el;
                }

                if (patches.type === 'UPDATE') {
                    if (patches.attrPatches) {
                        patchAttrs(el, patches.attrPatches);
                    }

                    if (patches.childPatches) {
                        patchChildren(el, patches.childPatches);
                    }
                }

                return el;
            }

            function patchAttrs(el, attrPatches) {
                for (let key in attrPatches) {
                    const value = attrPatches[key];

                    if (key === 'className') key = 'class';

                    if (key.startsWith('on')) {
                        const eventName = key.substring(2).toLowerCase();
                        const oldHandler = el['_' + eventName];
                        if (oldHandler) {
                            el.removeEventListener(eventName, oldHandler);
                        }
                        if (value) {
                            el.addEventListener(eventName, value);
                            el['_' + eventName] = value;
                        }
                        continue;
                    }

                    if (value === undefined) {
                        el.removeAttribute(key);
                    } else if (key === 'style' && typeof value === 'object') {
                        Object.assign(el.style, value);
                    } else if (key === 'checked' || key === 'disabled') {
                        el[key] = value;
                    } else if (key === 'value') {
                        el.value = value;
                    } else {
                        setAttribute(el, key, value);
                    }
                }
            }

            function patchChildren(el, childPatches) {
                childPatches.forEach((childPatch, i) => {
                    if (!childPatch) return;

                    const childEl = el.childNodes[i];

                    if (childPatch.type === 'ADD') {
                        el.appendChild(createElement(childPatch.newVNode));
                    } else if (childPatch.type === 'REMOVE') {
                        el.removeChild(childEl);
                    } else {
                        patch(childEl, childPatch);
                    }
                });
            }

            function createStore(initialState = {}) {
                let state = { ...initialState };
                let listeners = [];

                return {
                    getState() {
                        return state;
                    },

                    setState(updates) {
                        if (typeof updates === 'function') {
                            updates = updates(state);
                        }

                        state = { ...state, ...updates };
                        listeners.forEach(listener => listener(state));
                    },

                    subscribe(listener) {
                        listeners.push(listener);
                        return () => {
                            listeners = listeners.filter(l => l !== listener);
                        };
                    }
                };
            }

            function createRouter(routes) {
                let currentRoute = null;
                const listeners = [];

                function matchRoute(path) {
                    for (let pattern in routes) {
                        const params = matchPath(pattern, path);
                        if (params !== null) {
                            return {
                                pattern,
                                component: routes[pattern],
                                params,
                                path
                            };
                        }
                    }
                    return null;
                }

                function matchPath(pattern, path) {
                    const patternParts = pattern.split('/').filter(Boolean);
                    const pathParts = path.split('/').filter(Boolean);

                    if (patternParts.length !== pathParts.length) {
                        return null;
                    }

                    const params = {};

                    for (let i = 0; i < patternParts.length; i++) {
                        const patternPart = patternParts[i];
                        const pathPart = pathParts[i];

                        if (patternPart.startsWith(':')) {
                            params[patternPart.slice(1)] = pathPart;
                        } else if (patternPart !== pathPart) {
                            return null;
                        }
                    }

                    return params;
                }

                function handleRouteChange() {
                    const hash = window.location.hash.slice(1) || '/';
                    const route = matchRoute(hash);

                    if (route) {
                        currentRoute = route;
                        listeners.forEach(listener => listener(route));
                    }
                }

                return {
                    start() {
                        window.addEventListener('hashchange', handleRouteChange);
                        handleRouteChange();
                    },

                    navigate(path) {
                        window.location.hash = path;
                    },

                    getCurrentRoute() {
                        return currentRoute;
                    },

                    subscribe(listener) {
                        listeners.push(listener);
                        if (currentRoute) {
                            listener(currentRoute);
                        }
                        return () => {
                            const index = listeners.indexOf(listener);
                            if (index > -1) listeners.splice(index, 1);
                        };
                    }
                };
            }

            const MiniFlux = {
                h,
                render,
                createStore,
                createRouter
            };

            global.MiniFlux = MiniFlux;
            global.h = h;

        })(window);

        /**
         * TodoMVC Application
         */
        const { h, render, createStore, createRouter } = MiniFlux;

        // Create store with initial state
        const store = createStore({
            todos: [],
            filter: 'all',
            editingId: null
        });

        // Router setup
        const router = createRouter({
            '/': () => store.setState({ filter: 'all' }),
            '/active': () => store.setState({ filter: 'active' }),
            '/completed': () => store.setState({ filter: 'completed' })
        });

        // Utility functions
        function saveTodos(todos) {
            localStorage.setItem('todos-miniflux', JSON.stringify(todos));
        }

        function loadTodos() {
            const stored = localStorage.getItem('todos-miniflux');
            return stored ? JSON.parse(stored) : [];
        }

        // Initialize todos from localStorage
        store.setState({ todos: loadTodos() });

        // Todo Actions
        function addTodo(text) {
            const state = store.getState();
            const newTodos = [...state.todos, {
                id: Date.now(),
                text: text.trim(),
                completed: false
            }];
            store.setState({ todos: newTodos });
            saveTodos(newTodos);
        }

        function toggleTodo(id) {
            const state = store.getState();
            const newTodos = state.todos.map(todo =>
                todo.id === id ? { ...todo, completed: !todo.completed } : todo
            );
            store.setState({ todos: newTodos });
            saveTodos(newTodos);
        }

        function toggleAll() {
            const state = store.getState();
            const allCompleted = state.todos.every(t => t.completed);
            const newTodos = state.todos.map(todo => ({
                ...todo,
                completed: !allCompleted
            }));
            store.setState({ todos: newTodos });
            saveTodos(newTodos);
        }

        function destroyTodo(id) {
            const state = store.getState();
            const newTodos = state.todos.filter(todo => todo.id !== id);
            store.setState({ todos: newTodos });
            saveTodos(newTodos);
        }

        function editTodo(id) {
            store.setState({ editingId: id });
        }

        function saveTodoEdit(id, text) {
            const state = store.getState();
            if (text.trim()) {
                const newTodos = state.todos.map(todo =>
                    todo.id === id ? { ...todo, text: text.trim() } : todo
                );
                store.setState({ todos: newTodos, editingId: null });
                saveTodos(newTodos);
            } else {
                destroyTodo(id);
            }
        }

        function cancelEdit() {
            store.setState({ editingId: null });
        }

        function clearCompleted() {
            const state = store.getState();
            const newTodos = state.todos.filter(todo => !todo.completed);
            store.setState({ todos: newTodos });
            saveTodos(newTodos);
        }

        // Components
        function TodoItem(todo, isEditing) {
            const liClass = [
                todo.completed ? 'completed' : '',
                isEditing ? 'editing' : ''
            ].filter(Boolean).join(' ');

            return h('li', { class: liClass, key: todo.id }, [
                h('div', { class: 'view' }, [
                    h('input', {
                        class: 'toggle',
                        type: 'checkbox',
                        checked: todo.completed,
                        onchange: () => toggleTodo(todo.id)
                    }),
                    h('label', {
                        ondblclick: () => editTodo(todo.id)
                    }, todo.text),
                    h('button', {
                        class: 'destroy',
                        onclick: () => destroyTodo(todo.id)
                    })
                ]),
                isEditing && h('input', {
                    class: 'edit',
                    value: todo.text,
                    onkeydown: (e) => {
                        if (e.key === 'Enter') {
                            saveTodoEdit(todo.id, e.target.value);
                        } else if (e.key === 'Escape') {
                            cancelEdit();
                        }
                    },
                    onblur: (e) => saveTodoEdit(todo.id, e.target.value)
                })
            ]);
        }

        function TodoApp() {
            const state = store.getState();
            const { todos, filter, editingId } = state;

            const filteredTodos = todos.filter(todo => {
                if (filter === 'active') return !todo.completed;
                if (filter === 'completed') return todo.completed;
                return true;
            });

            const activeTodoCount = todos.filter(t => !t.completed).length;
            const completedCount = todos.length - activeTodoCount;

            return h('div', {}, [
                h('section', { class: 'todoapp' }, [
                    h('header', { class: 'header' }, [
                        h('h1', {}, 'todos'),
                        h('input', {
                            class: 'new-todo',
                            placeholder: 'What needs to be done?',
                            autofocus: true,
                            onkeydown: (e) => {
                                if (e.key === 'Enter' && e.target.value.trim()) {
                                    addTodo(e.target.value);
                                    e.target.value = '';
                                }
                            }
                        })
                    ]),
                    todos.length > 0 && h('section', { class: 'main' }, [
                        h('input', {
                            id: 'toggle-all',
                            class: 'toggle-all',
                            type: 'checkbox',
                            checked: activeTodoCount === 0,
                            onchange: toggleAll
                        }),
                        h('label', { for: 'toggle-all' }, 'Mark all as complete'),
                        h('ul', { class: 'todo-list' },
                            filteredTodos.map(todo => TodoItem(todo, todo.id === editingId))
                        )
                    ]),
                    todos.length > 0 && h('footer', { class: 'footer' }, [
                        h('span', { class: 'todo-count' }, [
                            h('strong', {}, activeTodoCount),
                            ` item${activeTodoCount !== 1 ? 's' : ''} left`
                        ]),
                        h('ul', { class: 'filters' }, [
                            h('li', {}, h('a', {
                                href: '#/',
                                class: filter === 'all' ? 'selected' : ''
                            }, 'All')),
                            h('li', {}, h('a', {
                                href: '#/active',
                                class: filter === 'active' ? 'selected' : ''
                            }, 'Active')),
                            h('li', {}, h('a', {
                                href: '#/completed',
                                class: filter === 'completed' ? 'selected' : ''
                            }, 'Completed'))
                        ]),
                        completedCount > 0 && h('button', {
                            class: 'clear-completed',
                            onclick: clearCompleted
                        }, 'Clear completed')
                    ])
                ]),
                h('footer', { class: 'info' }, [
                    h('p', {}, 'Double-click to edit a todo'),
                    h('p', {}, [
                        'Created with ',
                        h('a', { href: '#' }, 'MiniFlux')
                    ])
                ])
            ]);
        }

        // Subscribe to state changes and re-render
        store.subscribe(() => {
            render(TodoApp(), document.getElementById('app'));
        });

        // Subscribe to route changes
        router.subscribe(() => {
            render(TodoApp(), document.getElementById('app'));
        });

        // Start router
        router.start();

        // Initial render
        render(TodoApp(), document.getElementById('app'));
    </script>
</body>

</html>